<!DOCTYPE html>
  <html>
    <head>
      <title>gradle-guide</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///C:\Users\wangw\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.3.5\node_modules\@shd101wyy\mume\dependencies\katex\katex.min.css">
      
      
      
      
      
      
      
      
      
      

      <style> 
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
.markdown-preview.markdown-preview {
  font-size: 14px;
  -webkit-font-smoothing: antialiased;
  color: black;
  /* 等宽字体 */
  /* HEAD字体 */
  /* 文本字体 */
  font-family: Geneva, Arial, Helvetica, "Microsoft YaHei", "华文细黑", sans-serif;
}
.markdown-preview.markdown-preview h1,
.markdown-preview.markdown-preview h2,
.markdown-preview.markdown-preview h3,
.markdown-preview.markdown-preview h4,
.markdown-preview.markdown-preview h5,
.markdown-preview.markdown-preview h6 {
  font-family: Geneva, Arial, Helvetica, "Microsoft YaHei", sans-serif;
}
.markdown-preview.markdown-preview pre,
.markdown-preview.markdown-preview code {
  font-family: "Yahei Ubuntu Mono", "Consolas", "Courier New", sans-serif;
  background-color: whitesmoke;
}
.markdown-preview.markdown-preview.phantomjs-pdf {
  font-family: Geneva, Arial, Helvetica, "Microsoft YaHei", "华文细黑", sans-serif;
  font-size: 14px;
  color: black;
  background-color: white;
}
.markdown-preview.markdown-preview.phantomjs-pdf pre,
.markdown-preview.markdown-preview.phantomjs-pdf code {
  background-color: white;
}
.markdown-preview.markdown-preview.phantomjs-pdf pre {
  color: black;
  border-style: solid;
  border-width: thin;
}
.markdown-preview.markdown-preview.phantomjs-pdf .token {
  color: black;
}
 
      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview   ">
      <h1 class="mume-header undefined" id="gradle">Gradle</h1>

<ul>
<li><a href="#gradle-user-guide">Gradle User Guide</a></li>
<li><a href="#gradle-cargo-plugin%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8">Gradle Cargo plugin部署项目到远程服务器</a></li>
<li><a href="#gradle-ssh-plugin%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8">Gradle SSH Plugin部署项目到远程服务器</a></li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B">Gradle入门系列：简介</a>
<ul>
<li><a href="#gradle%E6%9E%84%E5%BB%BA%E7%AE%80%E4%BB%8B">Gradle构建简介</a></li>
<li><a href="#gradle%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B">Gradle插件简介</a></li>
</ul>
</li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E9%A1%B9%E7%9B%AE">Gradle入门系列：第一个Java项目</a></li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">Gradle入门系列：依赖管理</a>
<ul>
<li><a href="#java%E6%BC%94%E7%A4%BA%E9%A1%B9%E7%9B%AE">Java演示项目</a></li>
</ul>
</li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC">Gradle入门系列：创建二进制发布版本</a></li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BA%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">Gradle入门系列：创建多项目构建</a>
<ul>
<li><a href="#gradle-build-%E7%9A%84%E9%9C%80%E6%B1%82">Gradle Build 的需求</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">创建一个多项目构建</a></li>
</ul>
</li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BAweb%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE">Gradle入门系列：创建Web应用项目</a></li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E5%88%9B%E5%BB%BA-spring-boot-web-%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE">Gradle入门：创建 Spring Boot Web 应用项目</a></li>
<li><a href="#gradle%E6%9E%84%E5%BB%BAjava%E9%A1%B9%E7%9B%AE">Gradle构建java项目</a>
<ul>
<li><a href="#java-%E6%8F%92%E4%BB%B6">Java 插件</a></li>
<li><a href="#%E6%9C%80%E7%AE%80%E5%8D%95java%E9%A1%B9%E7%9B%AE">最简单java项目</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96java%E9%A1%B9%E7%9B%AE-japp">初始化java项目 (japp)</a></li>
<li><a href="#java%E6%BC%94%E7%A4%BA%E9%A1%B9%E7%9B%AE-javaapp">Java演示项目 (javaapp)</a></li>
</ul>
</li>
<li><a href="#java-%E6%9E%84%E5%BB%BA%E5%85%A5%E9%97%A8">Java 构建入门</a>
<ul>
<li><a href="#java-%E6%8F%92%E4%BB%B6-1">Java 插件</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84-java-%E9%A1%B9%E7%9B%AE">一个基础的 Java 项目</a></li>
<li><a href="#%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%9A%84-java-%E6%9E%84%E5%BB%BA">多项目的 Java 构建</a></li>
</ul>
</li>
<li><a href="#java-gradle%E4%B9%8Bgretty%E6%8F%92%E4%BB%B6">Java Gradle之gretty插件</a></li>
</ul>
<hr>
<h2 class="mume-header" id="gradle-user-guide">Gradle User Guide</h2>

<p><strong>文档参考</strong></p>
<ul>
<li><a href="https://docs.gradle.org/current/userguide/userguide.html">Gradle User Guide</a></li>
<li><a href="http://udn.yyuap.com/doc/wiki/project/GradleUserGuide-Wiki/index.html">Gradle User Guide 中文版</a></li>
<li><a href="hhttp://blog.jobbole.com/71999/">Gradle入门系列</a></li>
<li><a href="https://www.petrikainulainen.net/getting-started-with-gradle/">Getting Started With Gradle</a></li>
</ul>
<hr>
<h2 class="mume-header" id="gradle-cargo-plugin%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8">Gradle Cargo plugin部署项目到远程服务器</h2>

<p>参考文档</p>
<ul>
<li><a href="http://zhangley.com/article/cargo-gradle/">http://zhangley.com/article/cargo-gradle/</a></li>
<li><a href="https://github.com/bmuschko/gradle-cargo-plugin">GitHub bmuschko/gradle-cargo-plugin</a></li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply&#xA0;plugin:&#xA0;&apos;cargo&apos;

cargo {
    containerId = &apos;tomcat6x&apos;
    port = 9090

    deployable {
        context = &apos;myawesomewebapp&apos;
    }

    remote {
        hostname = &apos;cloud.internal.it&apos;
        username = &apos;superuser&apos;
        password = &apos;secretpwd&apos;
    }

    local {
        homeDir = file(&apos;/home/user/dev/tools/apache-tomcat-6.0.32&apos;)
        outputFile = file(&apos;build/output.log&apos;)
        timeout = 60000

        containerProperties {
            property &apos;cargo.tomcat.ajp.port&apos;, 9099
        }
    }
}
</code></pre><hr>
<h2 class="mume-header" id="gradle-ssh-plugin%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8">Gradle SSH Plugin部署项目到远程服务器</h2>

<p>参考文档</p>
<ul>
<li><a href="http://blog.csdn.net/honghailiang888/article/details/54944621">Gradle构建并自动部署Java Web项目到远程服务器</a></li>
<li><a href="https://gradle-ssh-plugin.github.io/">Deploy your App from Gradle</a></li>
<li><a href="https://github.com/gradle-ssh-plugin/template">GitHub gradle-ssh-plugin/template</a></li>
</ul>
<p><strong>Gradle SSH Plugin</strong></p>
<pre data-role="codeBlock" data-info="" class="language-"><code>// build.gradle
plugins {
  id &apos;org.hidetake.ssh&apos; version &apos;2.9.0&apos;
}

remotes {
  webServer {
    host = &apos;192.168.1.101&apos;
    user = &apos;jenkins&apos;
    identity = file(&apos;id_rsa&apos;)
  }
}

task deploy {
  doLast {
    ssh.run {
      session(remotes.webServer) {
        put from: &apos;example.war&apos;, into: &apos;/webapps&apos;
        execute &apos;sudo service tomcat restart&apos;
      }
    }
  }
}
</code></pre><p>思路介绍：</p>
<ul>
<li>停止对应项目的tomcat服务器</li>
<li>删除webapps其下的对应项目文件</li>
<li>构建war包并将war包传送到tomcat服务器webapps目录下</li>
<li>启动tomcat</li>
</ul>
<p>配置build.gradle</p>
<ul>
<li>配置ssh插件、提供远程服务器登陆，文件传输，命令执行等支持</li>
<li>配置远程服务器信息</li>
<li>配置gradle task、共四个任务：关闭tomcat、删除war包及目录、拷贝文件、启动tomcat，且后者依赖前者</li>
</ul>
<h5 class="mume-header" id="gradle-ssh-plugin-template">Gradle SSH Plugin Template</h5>

<p>build.gradle 模板</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>plugins {
    id &apos;war&apos;
    id &apos;org.hidetake.ssh&apos; version &apos;2.9.0&apos;
}

ssh.settings {
    dryRun = project.hasProperty(&apos;dryRun&apos;)
}

remotes {
    localhost {
        host = &apos;localhost&apos;
        user = System.properties[&apos;user.name&apos;]
        identity = file(&quot;${System.properties[&apos;user.home&apos;]}/.ssh/id_rsa&quot;)
    }
}

task showPlatformVersion &lt;&lt; {
    println ssh.version
    ssh.run {
        session(remotes.localhost) {
            execute &apos;uname -a&apos;
            execute &apos;cat /etc/*-release&apos;, ignoreError: true
        }
    }
}

task deploy(dependsOn: war) &lt;&lt; {
    ssh.run {
        session(remotes.localhost) {
            put from: war.archivePath.path, into: &apos;/webapps&apos;
            execute &apos;sudo service tomcat restart&apos;
        }
    }
}
</code></pre><hr>
<h2 class="mume-header" id="gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B">Gradle入门系列：简介</h2>

<p>参考文档</p>
<ul>
<li><a href="http://blog.jobbole.com/71999/">GradGradle入门系列（1）：简介</a></li>
<li><a href="http://www.petrikainulainen.net/getting-started-with-gradle/">Getting Started With Gradle</a></li>
</ul>
<p>下载安装gradle。<br>
安装验证： <code>gradle -v</code></p>
<h3 class="mume-header" id="gradle%E6%9E%84%E5%BB%BA%E7%AE%80%E4%BB%8B">Gradle构建简介</h3>

<p>在Gradle中，有两个基本概念：项目和任务。请看以下详解：</p>
<ul>
<li>项目是指我们的构建产物（比如Jar包）或实施产物（将应用程序部署到生产环境）。一个项目包含一个或多个任务。</li>
<li>任务是指不可分的最小工作单元，执行构建工作（比如编译项目或执行测试）。</li>
</ul>
<p>那么，这些概念和Gradle的构建又有什么联系呢？好，每一次Gradle的构建都包含一个或多个项目。</p>
<p>我们能够使用以下配置文件对Gradle的构建进行配置：</p>
<ul>
<li><a href="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html">Gradle构建脚本</a>（<code>build.gradle</code>）指定了一个项目和它的任务。</li>
<li><a href="http://www.gradle.org/docs/current/userguide/build_environment.html#sec:gradle_configuration_properties">Gradle属性文件</a>（<code>gradle.properties</code>）用来配置构建属性。</li>
<li><a href="http://www.gradle.org/docs/current/userguide/build_lifecycle.html#sec:settings_file">Gradle设置文件</a>（<code>gradle.settings</code>）对于只有一个项目的构建而言是可选的，如果我们的构建中包含多于一个项目，那么它就是必须的，因为它描述了哪一个项目参与构建。每一个多项目的构建都必须在项目结构的根目录中加入一个设置文件。</li>
</ul>
<h3 class="mume-header" id="gradle%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B">Gradle插件简介</h3>

<p>Gradle的设计理念是，所有有用的特性都由<a href="http://www.gradle.org/docs/current/userguide/plugins.html">Gradle插件</a>提供，一个Gradle插件能够：</p>
<ul>
<li>在项目中添加新任务</li>
<li>为新加入的任务提供默认配置，这个默认配置会在项目中注入新的约定（如源文件位置）。</li>
<li>加入新的属性，可以覆盖插件的默认配置属性。</li>
<li>为项目加入新的依赖。</li>
</ul>
<p>Gradle用户手册提供了<a href="https://docs.gradle.org/current/userguide/standard_plugins.html">一系列标准Gradle插件</a>。<br>
在我们为项目加入Gradle插件时，我们可以根据名称或类型来指定Gradle插件。<br>
我们可以将下面这行代码加入到<code>build.gradle</code>文件中，它通过名称指定Gradle插件（这里的名称是foo）：<br>
<code>apply plugin: 'foo'</code></p>
<hr>
<h2 class="mume-header" id="gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E9%A1%B9%E7%9B%AE">Gradle入门系列：第一个Java项目</h2>

<p>参考文档</p>
<ul>
<li><a href="http://blog.jobbole.com/72558/">Gradle入门系列（2）：第一个Java项目</a></li>
<li><a href="http://www.petrikainulainen.net/programming/gradle/getting-started-with-gradle-our-first-java-project/">Getting Started with Gradle: Our First Java Project</a></li>
<li><a href="https://github.com/pkainulainen/gradle-examples/tree/master/first-java-project">Github</a></li>
</ul>
<p>该Java项目只有一个需求：我们的构建脚本必须创建一个可执行的Jar文件，换句话说，我们必须能够使用命令java -jar jarfile.jar 来运行我们的程序。</p>
<p>使用Java插件, build.gradle</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;

jar {
    manifest {
        attributes &apos;Main-Class&apos;: &apos;net.petrikainulainen.gradle.HelloWorld&apos;
    }
}
</code></pre><p>Java项目结构</p>
<ul>
<li><code>src/main/java</code>目录包含了项目的源代码。</li>
<li><code>src/main/resources</code>目录包含了项目的资源（如属性文件）。</li>
<li><code>src/test/java</code>目录包含了测试类。</li>
<li><code>src/test/resources</code>目录包含了测试资源。</li>
</ul>
<p>所有我们构建生成的文件都会在<code>build</code> 目录下被创建，这个目录涵盖了以下的子目录。</p>
<ul>
<li><code>classes</code>目录包含编译过的<code>.class</code>文件。</li>
<li><code>libs</code>目录包含构建生成的<code>jar</code>或<code>war</code>文件。</li>
</ul>
<pre data-role="codeBlock" data-info="java" class="language-java"><span class="token keyword">package</span> net<span class="token punctuation">.</span>petrikainulainen<span class="token punctuation">.</span>gradle<span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p>Java工程中的任务<br>
Java插件在我们的构建中加入了很多任务，我们这篇教程涉及到的任务如下：</p>
<ul>
<li><code>assemble</code>任务会编译程序中的源代码，并打包生成Jar文件，这个任务不执行单元测试。</li>
<li><code>build</code>任务会执行一个完整的项目构建。</li>
<li><code>clean</code>任务会删除构建目录。</li>
<li><code>compileJava</code>任务会编译程序中的源代码。</li>
</ul>
<p>运行: <code>java -jar first-java-project.jar</code></p>
<p>配置Jar文件的主类</p>
<ul>
<li>Java插件在我们的项目中加入了一个Jar任务，每一个Jar对象都一个<code>manifest</code>属性，这个属性是<code>Manifest</code>的一个实例。</li>
<li>我们可以对生成的Jar文件的主类进行配置，使用<code>Manifest</code>接口的<code>attributes()</code>方法。<br>
<code>jar { manifest { attributes 'Main-Class': 'net.petrikainulainen.gradle.HelloWorld' } }</code></li>
</ul>
<p><span id="gradleguide003"></span></p>
<h2 class="mume-header" id="gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">Gradle入门系列：依赖管理</h2>

<p>参考文档</p>
<ul>
<li><a href="http://blog.jobbole.com/72992/">Gradle入门系列（3）：依赖管理</a></li>
<li><a href="http://www.petrikainulainen.net/programming/gradle/getting-started-with-gradle-dependency-management/">Getting Started with Gradle: Dependency Management</a></li>
<li><a href="https://github.com/pkainulainen/gradle-examples/tree/master/dependency-management">Github</a></li>
</ul>
<p>在现实生活中，要创造一个没有任何外部依赖的应用程序并非不可能，但也是极具挑战的。这也是为什么依赖管理对于每个软件项目都是至关重要的一部分。</p>
<p>这篇教程主要讲述如何使用Gradle管理我们项目的依赖，我们会学习配置应用仓库以及所需的依赖，我们也会理论联系实际，实现一个简单的演示程序。</p>
<h4 class="mume-header" id="%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86">仓库管理</h4>

<p>本质上说，仓库是一种存放依赖的容器，每一个项目都具备一个或多个仓库。<br>
Gradle支持以下仓库格式：</p>
<ul>
<li>Ivy仓库</li>
<li>Maven仓库</li>
<li>Flat directory仓库</li>
</ul>
<p><strong>在构建中加入Ivy仓库</strong><br>
我们可以通过URL地址或本地文件系统地址，将Ivy仓库加入到我们的构建中。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>repositories {
  ivy { url &quot;http://ivy.petrikainulainen.net/repo&quot; }
  ivy { url &quot;../ivy-repo&quot; }
}
</code></pre><p><strong>在构建中加入Maven仓库</strong><br>
可以通过URL地址或本地文件系统地址，将Maven仓库加入到我们的构建中。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>repositories {
  maven { url &quot;http://maven.petrikainulainen.net/repo&quot; }
  maven { url &quot;../maven-repo&quot; }
  jcenter()
  mavenLocal()
  mavenCentral()
}
</code></pre><p>在加入Maven仓库时，Gradle提供了三种“别名”供我们使用，它们分别是：</p>
<ul>
<li><code>jcenter()</code>别名，表示依赖是从Bintary’s JCenter Maven 仓库中获取的。</li>
<li><code>mavenLocal()</code>别名，表示依赖是从本地的Maven仓库中获取的。</li>
<li><code>mavenCentral()</code>别名，表示依赖是从Central Maven 2 仓库中获取的。</li>
</ul>
<p><strong>在构建中加入Flat Directory仓库</strong><br>
这意味着系统将在<code>lib</code>, <code>libB</code>目录下搜索依赖</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>repositories {
  flatDir { dirs &apos;lib&apos;,&apos;libB&apos; }
}
</code></pre><h4 class="mume-header" id="%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">依赖管理</h4>

<p>在配置完项目仓库后，我们可以声明其中的依赖，如果我们想要声明一个新的依赖，可以采用如下步骤：</p>
<ol>
<li>指定依赖的配置。</li>
<li>声明所需的依赖。</li>
</ol>
<p><strong>配置中的依赖分类</strong><br>
在Gradle中，依赖是按照指定名称进行分类的，这些分类被称为配置项，我们可以使用配置项声明项目的外部依赖。<br>
Java插件指定了若干依赖配置项，其描述如下：</p>
<ul>
<li>当项目的源代码被编译时，<code>compile</code>配置项中的依赖是必须的。</li>
<li><code>runtime</code>配置项中包含的依赖在运行时是必须的。</li>
<li><code>testCompile</code>配置项中包含的依赖在编译项目的测试代码时是必须的。</li>
<li><code>testRuntime</code>配置项中包含的依赖在运行测试代码时是必须的。</li>
<li><code>archives</code>配置项中包含项目生成的文件（如Jar文件）。</li>
<li><code>default</code>配置项中包含运行时必须的依赖。</li>
</ul>
<p><strong>声明项目依赖</strong><br>
最普遍的依赖称为外部依赖，这些依赖存放在外部仓库中。一个外部依赖可以由以下属性指定：</p>
<ul>
<li><code>group</code>属性指定依赖的分组（在Maven中，就是<code>groupId</code>）。</li>
<li><code>name</code>属性指定依赖的名称（在Maven中，就是<code>artifactId</code>）。</li>
<li><code>version</code>属性指定外部依赖的版本（在Maven中，就是<code>version</code>）。</li>
</ul>
<blockquote>
<p>小贴士：这些属性在Maven仓库中是必须的，如果你使用其他仓库，一些属性可能是可选的。打个比方，如果你使用Flat directory仓库，你可能只需要指定名称和版本。</p>
</blockquote>
<p>指定以下依赖：依赖的分组是foo,依赖的名称是foo,依赖的版本是0.1。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>dependencies {
    compile group: &apos;foo&apos;, name: &apos;foo&apos;, version: &apos;0.1&apos;
}
</code></pre><p>我们也可以采用一种快捷方式声明依赖：<code>[group]:[name]:[version]</code>。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>dependencies {
  compile &apos;foo:foo:0.1&apos;
}
</code></pre><p>也可以在同一个配置项中加入多个依赖，传统的方式如下：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>dependencies {
&#xA0;&#xA0;&#xA0;&#xA0;compile (
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;[group: &apos;foo&apos;, name: &apos;foo&apos;, version: &apos;0.1&apos;],
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;[group: &apos;bar&apos;, name: &apos;bar&apos;, version: &apos;0.1&apos;]
&#xA0;&#xA0;&#xA0;&#xA0;)
}
</code></pre><p>或</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>dependencies {
&#xA0;&#xA0;&#xA0;&#xA0;compile &apos;foo:foo:0.1&apos;, &apos;bar:bar:0.1&apos;
}
</code></pre><p>声明属于不同配置项的依赖(快捷方式)</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>dependencies {
&#xA0;&#xA0;&#xA0;&#xA0;compile &apos;foo:foo:0.1&apos;
&#xA0;&#xA0;&#xA0;&#xA0;testCompile &apos;test:test:0.1&apos;
}
</code></pre><p><span id="dependency-management"></span></p>
<h3 class="mume-header" id="java%E6%BC%94%E7%A4%BA%E9%A1%B9%E7%9B%AE">Java演示项目</h3>

<p><a href="https://github.com/pkainulainen/gradle-examples/tree/master/dependency-management">dependency-management on GitHub</a></p>
<p><strong>项目说明</strong></p>
<ul>
<li>演示程序的构建脚本必须使用Maven central仓库。</li>
<li>演示程序必须使用Log4j写入日志。</li>
<li>演示程序必须包含包含单元测试，保证正确的信息返回，单元测试必须使用JUnit编写。</li>
<li>演示程序必须创建一个可执行的Jar文件。</li>
</ul>
<p><strong>项目目录结构</strong></p>
<pre data-role="codeBlock" data-info="" class="language-"><code>.
&#x251C;&#x2500;&#x2500; build.gradle
&#x251C;&#x2500;&#x2500; gradle
&#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; wrapper
&#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; gradle-wrapper.jar
&#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; gradle-wrapper.properties
&#x251C;&#x2500;&#x2500; gradlew
&#x251C;&#x2500;&#x2500; gradlew.bat
&#x251C;&#x2500;&#x2500; settings.gradle
&#x2514;&#x2500;&#x2500; src
    &#x251C;&#x2500;&#x2500; main
    &#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; java
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; com
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; dsl
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0;         &#x2514;&#x2500;&#x2500; gradle
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0;             &#x251C;&#x2500;&#x2500; HelloWorld.java
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0;             &#x2514;&#x2500;&#x2500; MessageService.java
    &#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; resources
    &#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; log4j.properties
    &#x2514;&#x2500;&#x2500; test
        &#x2514;&#x2500;&#x2500; java
            &#x2514;&#x2500;&#x2500; com
                &#x2514;&#x2500;&#x2500; dsl
                    &#x2514;&#x2500;&#x2500; gradle
                        &#x2514;&#x2500;&#x2500; MessageServiceTest.java
</code></pre><p>说明</p>
<ul>
<li><code>MessageService.java</code> 创建一个<code>MessageService</code>类，当其中的<code>getMessage()</code>方法被调用时，返回字符串<code>“Hello World!”</code>。</li>
<li><code>MessageServiceTest.java</code> 创建一个<code>MessageServiceTest</code>类，确保M<code>essageService</code>类中的<code>getMessage()</code>方法返回字符串<code>“Hello World!”</code>。</li>
<li><code>HelloWorld.java</code> 创建程序的主类，从<code>MessageService</code>对象获取信息，并使用<code>Log4j</code>写入日志。</li>
<li><code>log4j.properties</code> 配置<code>Log4j</code>。</li>
</ul>
<p><strong><code>build.gradle</code> 文件</strong></p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;
apply plugin: &apos;application&apos;

// &#x914D;&#x7F6E;&#x4ED3;&#x5E93;
repositories {
  mavenCentral()
}

// &#x4F9D;&#x8D56;&#x58F0;&#x660E;
dependencies {
  compile &apos;log4j:log4j:1.2.17&apos;
  testCompile &apos;junit:junit:4.12&apos;
}

// &#x6253;&#x5305;jar
jar {
  from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
  manifest {
    attributes &apos;Main-Class&apos;: &apos;net.petrikainulainen.gradle.HelloWorld&apos;
  }
}

mainClassName = &apos;net.petrikainulainen.gradle.HelloWorld&apos;
</code></pre><blockquote>
<p>说明：<br>
jar包中包含依赖的库<br>
<code>from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }</code></p>
</blockquote>
<p><strong>执行测试</strong></p>
<p><code>gradle test</code></p>
<ul>
<li><code>build/test-results</code> 目录包含每次测试执行的原始数据。</li>
<li><code>build/reports/tests</code> 目录包含一个HTML报告，描述了测试的结果。</li>
</ul>
<p><strong>打包和运行程序</strong></p>
<p><code>gradle assemble</code>或<code>gradle build</code></p>
<ul>
<li>生成: <code>build/libs/dependency-management.jar</code></li>
<li>运行: <code>java -jar build/libs/dependency-management.jar</code></li>
</ul>
<p><span id="gradleguide004"></span></p>
<h2 class="mume-header" id="gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC">Gradle入门系列：创建二进制发布版本</h2>

<p>参考文档</p>
<ul>
<li><a href="http://blog.jobbole.com/80340/">Gradle入门系列（4）：创建二进制发布版本</a></li>
<li><a href="http://www.petrikainulainen.net/programming/gradle/getting-started-with-gradle-creating-a-binary-distribution/">Getting Started with Gradle: Creating a Runnable Binary Distribution</a></li>
<li><a href="https://github.com/pkainulainen/gradle-examples/tree/master/runnable-binary-distribution">Github</a></li>
</ul>
<p>在创建了一个实用的应用程序之后，我们可能想将其与他人分享。其中一种方式就是创建一个可以从网站上下载的二进制文件。<br>
创建一个二进制发布版本，满足以下需求：</p>
<ul>
<li>二进制发布一定不能使用所谓的“fat jar”方式。换句话说，我们应用程序中的所有依赖一定不能被打包到该程序相同的jar包中。</li>
<li>二进制发布必须包含针对*nix和Windows操作系统的启动副本。</li>
<li>二进制发布的根目录必须包含许可证。</li>
</ul>
<p><code>application</code>插件是一种Gradle插件，让我们可以运行、安装应用程序并用非<code>“fat jar”</code>方式创建二进制发布版本。<br>
在<code>build.gradle</code>文件中做一些相应的更改，就可以进行二进制发布了。</p>
<ul>
<li>移除jar任务的配置。</li>
<li>为项目应用<code>application</code>插件。</li>
<li>对应用程序的主类进行配置，设置<code>mainClassName</code>属性。</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;application&apos;
mainClassName = &apos;net.petrikainulainen.gradle.HelloWorld&apos;
</code></pre><p><code>application</code>插件在项目中添加了5个任务：</p>
<ul>
<li><code>run</code>任务用以启动应用程序。</li>
<li><code>startScripts</code>任务会在<code>build/scripts</code>目录中创建启动脚本，这个任务所创建的启动脚本适用于Windows和*nix操作系统。</li>
<li><code>installApp</code>任务会在<code>build/install/[project name]</code>目录中安装应用程序。</li>
<li><code>distZip</code>任务用以创建二进制发布并将其打包为一个<code>zip</code>文件。可以在<code>build/distributions</code>目录下找到。</li>
<li><code>distTar</code>任务用以创建二进制发布并将其打包为一个<code>tar</code>文件。可以在<code>build/distributions</code>目录下找到。</li>
</ul>
<p><code>gradle distZip</code>或<code>gradle distTar</code> 创建二进制文件。</p>
<p>如果将<code>application</code>插件创建的二进制文件解压缩，可以得到以下目录结构：</p>
<ul>
<li><code>bin</code>目录：包括启动脚本。</li>
<li><code>lib</code>目录：包括应用程序的jar文件以及它的依赖。</li>
</ul>
<p>在二进制发布版本中添加应用程序许可证</p>
<ul>
<li>创建一个任务，将许可证从项目的根目录复制到<code>build</code>目录下。</li>
<li>将许可证加入到所创建的二进制发布的根目录下。</li>
</ul>
<p>将许可证文件复制到build目录下</p>
<ul>
<li>创建一个新的<code>Copy</code>任务，名为<code>copyLicense</code>。</li>
<li>使用<code>CopySpec</code>接口中的<code>from()</code>方法配置源文件，将“<code>LICENSE</code>”作为参数调用。</li>
<li>使用<code>CopySpec</code>接口中<code>into()</code>方法配置<code>target</code>目录，将<code>$buildDir</code>属性作为参数调用。</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-"><code>task copyLicense(type: Copy) {
&#xA0;&#xA0;&#xA0;&#xA0;from &quot;LICENSE&quot;
&#xA0;&#xA0;&#xA0;&#xA0;into &quot;$buildDir&quot;
}
</code></pre><p>将许可证文件加入到二进制发布文件中</p>
<ul>
<li>将<code>copyLicense</code>任务从一个<code>Copy</code>任务改为正常的Gradle任务，只需在它的声明中移除“<code>(type: Copy)</code>”字符串。</li>
<li>按照以下步骤修改copyLicense任务
<ul>
<li>配置<code>copyLicense</code>任务输出。创建一个新的文件对象，指向<code>build</code>目录的许可证文件，并将其设置为<code>outputs.file</code>属性值。</li>
<li>将许可证文件从项目的根目录复制到<code>build</code>目录下。</li>
</ul>
</li>
<li><code>application</code>插件在项目中设置了一个<code>CopySpec</code>属性，名为<code>applicationDistribution</code>。我们可以使用这个属性在已创建的二进制文件中加入许可证文件，步骤如下：
<ul>
<li>使用<code>CopySpec</code>接口中的<code>from()</code>方法配置许可证文件的位置，将<code>copyLicense</code>任务的输出作为方法参数。</li>
<li>使用<code>CopySpec</code>接口中<code>into()</code>方法配置<code>target</code>目录，将一个空的字符串作为参数调用方法。</li>
</ul>
</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;application&apos;
apply plugin: &apos;java&apos;
&#xA0;
repositories {
&#xA0;&#xA0;&#xA0;&#xA0;mavenCentral()
}
&#xA0;
dependencies {
&#xA0;&#xA0;&#xA0;&#xA0;compile &apos;log4j:log4j:1.2.17&apos;
&#xA0;&#xA0;&#xA0;&#xA0;testCompile &apos;junit:junit:4.11&apos;
}
&#xA0;
mainClassName = &apos;net.petrikainulainen.gradle.HelloWorld&apos;
&#xA0;
task copyLicense {
&#xA0;&#xA0;&#xA0;&#xA0;outputs.file new File(&quot;$buildDir/LICENSE&quot;)
&#xA0;&#xA0;&#xA0;&#xA0;doLast {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;copy {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;from &quot;LICENSE&quot;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;into &quot;$buildDir&quot;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;&#xA0;&#xA0;}
}
&#xA0;
applicationDistribution.from(copyLicense) {
&#xA0;&#xA0;&#xA0;&#xA0;into &quot;&quot;
}
</code></pre><hr>
<h2 class="mume-header" id="gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BA%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">Gradle入门系列：创建多项目构建</h2>

<p>参考文档</p>
<ul>
<li><a href="http://blog.jobbole.com/84471/">Gradle入门系列（5）：创建多项目构建</a></li>
<li><a href="http://www.petrikainulainen.net/programming/gradle/getting-started-with-gradle-creating-a-multi-project-build/">Getting Started with Gradle: Creating a Multi-Project Build</a></li>
<li><a href="https://github.com/pkainulainen/gradle-examples/tree/master/multi-project-build">Github</a></li>
</ul>
<p>尽管我们可以仅使用单个组件来创建可工作的应用程序，但有时候更广泛的做法是将应用程序划分为多个更小的模块。<br>
由于这是一个非常普通的案例，因此每个成熟的构建工具都必须支持这项功能，Gradle也不例外。倘若Gradle项目拥有多于一个组件，我们就将其称之为多项目构建（multi-project build）。</p>
<h3 class="mume-header" id="gradle-build-%E7%9A%84%E9%9C%80%E6%B1%82">Gradle Build 的需求</h3>

<p>我们的示例程序拥有两个模块：</p>
<ul>
<li><code>core</code>模块包含一些通用的组件，它们能够被程序的其他模块使用。在我们的例子上，只包含一个类：<code>MessageService</code>类返回‘Hello World!’字符串。该模块只有一个依赖：它包含一个单元测试，使用<code>Junit 4.11</code>。</li>
<li><code>app</code>模块包含<code>HelloWorld</code>类，是程序的开端，它从<code>MessageService</code>对象中获取信息，并将接收到的信息写入一个日志文件中。该模块拥有两个依赖：它需要<code>core</code>模块，还使用<code>Log4j 1.2.17</code>作为日志库。</li>
</ul>
<p>我们的Gradle构建还有其他两个需求：</p>
<ul>
<li>我们必须要使用Gradle运行程序。</li>
<li>我们必须要创建一个可运行的二进制发布，而且不能使用所谓的<code>“fat jar”</code>方式。</li>
</ul>
<h3 class="mume-header" id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">创建一个多项目构建</h3>

<p>下一步，我们将创建一个多项目的Gradle构建，包括两个子项目：<code>app</code> 和 <code>core</code>。初始阶段，先要建立Gradle构建的目录结构。</p>
<p><strong>建立目录结构</strong><br>
由于<code>core</code>和<code>app</code>模块都使用Java语言，而且它们都使用Java项目的默认项目布局，我们根据以下步骤建立正确的目录结构：</p>
<ul>
<li>建立<code>core</code>模块的根目录(<code>core</code>)，并建立以下子目录：
<ul>
<li><code>src/main/java</code>目录包含<code>core</code>模块的源代码。</li>
<li><code>src/test/java</code>目录包含<code>core</code>模块的单元测试。</li>
</ul>
</li>
<li>建立<code>app</code>模块的根目录(<code>app</code>)，并建立以下子目录：
<ul>
<li><code>src/main/java</code>目录包含<code>app</code>模块的源代码。</li>
<li><code>src/main/resources</code>目录包含<code>app</code>模块的资源文件。</li>
</ul>
</li>
</ul>
<p><strong>对包含在多项目构建中的项目进行配置</strong></p>
<ul>
<li>在根项目的根目录下创建<code>settings.gradle</code>文件，一个多项目Gradle构建必须含有这个文件，因为它指明了那些包含在多项目构建中的项目。</li>
<li>确保<code>app</code>和<code>core</code>项目包含在我们的多项目构建中。</li>
</ul>
<p><code>settings.gradle</code>文件如下：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>include &apos;app&apos;
include &apos;core&apos;
</code></pre><p><strong>配置 core 项目</strong></p>
<ul>
<li>在<code>core</code>项目的根目录下创建<code>build.gradle</code>文件。</li>
<li>使用Java插件创建一个Java项目。</li>
<li>确保<code>core</code>项目从Maven2中央仓库(central Maven2 repository)中获取依赖。</li>
<li>声明JUnit依赖(版本4.11)，并使用<code>testCompile</code>配置项，该配置项表明：<code>core</code>项目在它的单元测试被编译前，需要JUnit库。</li>
</ul>
<p>core项目的<code>build.gradle</code>文件如下：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;
&#xA0;
repositories {
    mavenCentral()
}
&#xA0;
dependencies {
    testCompile &apos;junit:junit:4.11&apos;
}
</code></pre><p><strong>配置App项目</strong></p>
<p>在配置app项目之前，我们先来快速浏览一下对一些特殊依赖的依赖管理，这些依赖都是同一个多项目构建的一部分，我们将其称之为”项目依赖“。<br>
如果多项目构建拥有项目A和B，同时，项目B的编译需要项目A，我们可以通过在项目B的<code>build.gradle</code>文件中添加以下依赖声明来进行依赖配置。</p>
<ul>
<li>在app项目的根目录下创建build.gradle文件。</li>
<li>用Java插件创建一个Java项目。</li>
<li>确保app项目从Maven2中央仓库(central Maven2 repository)中获取依赖。</li>
<li>配置所需的依赖，app项目在编译时需要两个依赖：
<ul>
<li>Log4j (version 1.2.17)</li>
<li>core 模块</li>
</ul>
</li>
<li>创建二进制发布版本</li>
</ul>
<p><code>app</code>项目的<code>build.gradle</code>文件如下：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;application&apos;
apply plugin: &apos;java&apos;

repositories {
&#xA0;&#xA0;&#xA0;&#xA0;mavenCentral()
}
&#xA0;
dependencies {
    compile &apos;log4j:log4j:1.2.17&apos;
    compile project(&apos;:core&apos;)
}

mainClassName = &apos;net.petrikainulainen.gradle.client.HelloWorld&apos;

task copyLicense {
    outputs.file new File(&quot;$buildDir/LICENSE&quot;)
    doLast {
        copy {
            from &quot;LICENSE&quot;
            into &quot;$buildDir&quot;
        }
    }
}

applicationDistribution.from(copyLicense) {
    into &quot;&quot;
}
</code></pre><p><strong>移除重复配置</strong></p>
<p>当我们对多项目构建中的子项目进行配置时，我们在core和app项目的构建脚本中添加了重复的配置。</p>
<ul>
<li>由于两个项目都是Java项目，因此它们都使用Java插件。</li>
<li>两个项目都使用Maven2中央仓库(central Maven2 repository)。</li>
</ul>
<p>两个构建脚本都包含以下配置：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;
&#xA0;
repositories {
    mavenCentral()
}
</code></pre><p>我们将这项配置转移到根项目的build.gradle文件中</p>
<ul>
<li><code>subprojects {}</code> 在根项目的子项目中添加通用的配置</li>
<li><code>allprojects {}</code> 配置项是被多项目构建中的所有项目所共享</li>
<li><code>project ':core' {}</code> <code>core</code> 项目的配置</li>
</ul>
<p>在根项目的<code>build.gradle</code>文件中移除了重复配置后，代码如下：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>subprojects {
&#xA0;&#xA0;&#xA0;&#xA0;apply plugin: &apos;java&apos;
&#xA0;
&#xA0;&#xA0;&#xA0;&#xA0;repositories {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;mavenCentral()
&#xA0;&#xA0;&#xA0;&#xA0;}
}
</code></pre><hr>
<h2 class="mume-header" id="gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BAweb%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE">Gradle入门系列：创建Web应用项目</h2>

<p>参考文档</p>
<ul>
<li><a href="http://blog.jobbole.com/94707/">Gradle入门系列（6）：创建Web应用项目</a></li>
<li><a href="http://www.petrikainulainen.net/programming/gradle/getting-started-with-gradle-creating-a-web-application-project/">Getting Started with Gradle: Creating a Web Application Project</a></li>
<li><a href="https://github.com/pkainulainen/gradle-examples/tree/master/web-application">Github</a></li>
</ul>
<p>如果要用 Java 和 Gradle 创建一个 Web 应用项目，我们首先需要创建一个 Java 项目.</p>
<p><strong>打包Web应用</strong></p>
<p>在我们使用War插件打包Web应用前，需要将其加入到构建中。</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;
apply plugin: &apos;war&apos;
</code></pre><p>War插件在项目的目录布局下添加了一个新的目录，加入了两个新的依赖管理配置项，以及在项目中添加了一个新的任务。这些变化的详细描述如下：</p>
<ul>
<li>War插件在项目的目录布局下添加了<code>src/main/webapp</code>目录，这个目录包含Web应用的源文件（CSS文件、Javascript文件、JSP文件等）。</li>
<li>War插件加入了两个新的依赖管理配置项<code>providedCompile</code>和 <code>providedRuntime</code>.，这两个配置项与<code>compile</code> 和 <code>runtime</code> 配置项的作用域相同，但是区别是这两个配置项所属的依赖不会被添加到WAR文件中。</li>
<li>War插件也会在应用项目中添加<code>war</code>任务，这个任务会将WAR文件置于<code>build/libs</code>目录中。</li>
</ul>
<p>即便War插件在项目的目录布局下添加了<code>src/main/webapp</code>目录，但它实际上并没有被真正创建。如果我们需要这个目录，那就必须自己来创建。</p>
<p><strong>运行Web应用</strong></p>
<p>我们可以使用Gretty在开发环境中运行Web应用，它支持Jetty和Tomcat，它也不会被Gradle缺少SLF4J绑定所导致的问题所困扰。我们继续进行配置构建并使用Gretty运行Web应用。</p>
<p>配置构建脚本的依赖。可以通过以下步骤完成：</p>
<ul>
<li>使用Bintray的JCenter Maven仓库配置构建脚本，进行依赖解析。</li>
<li>将Gretty插件的依赖加入到构建脚本的<code>classpath</code>中。</li>
</ul>
<p>应用Gretty插件</p>
<p>配置Gretty：</p>
<ul>
<li>配置Gretty，当运行Web应用时，使用Jetty 9作为servlet容器。</li>
<li>配置Jetty，监听8080端口。</li>
<li>配置Jetty，使用上下文路径’/’运行Web应用。</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-"><code>buildscript {
&#xA0;&#xA0;&#xA0;&#xA0;repositories {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;jcenter()
&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;&#xA0;&#xA0;dependencies {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;classpath &apos;org.akhikhl.gretty:gretty:+&apos;
&#xA0;&#xA0;&#xA0;&#xA0;}
}
&#xA0;
apply plugin: &apos;java&apos;
apply plugin: &apos;war&apos;
apply plugin: &apos;org.akhikhl.gretty&apos;
&#xA0;
gretty {
&#xA0;&#xA0;&#xA0;&#xA0;port = 8080
&#xA0;&#xA0;&#xA0;&#xA0;contextPath = &apos;/&apos;
&#xA0;&#xA0;&#xA0;&#xA0;servletContainer = &apos;jetty9&apos;
}
</code></pre><p><strong>构建运行应用</strong></p>
<p>现在，我们可以通过在命令提示符下运行以下命令，开启或终止我们的Web应用：</p>
<ul>
<li><code>gradle appStart</code>命令能运行Web应用。</li>
<li><code>gradle appStop</code>命令能终止Web应用。</li>
</ul>
<hr>
<h2 class="mume-header" id="gradle%E5%85%A5%E9%97%A8%E5%88%9B%E5%BB%BA-spring-boot-web-%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE">Gradle入门：创建 Spring Boot Web 应用项目</h2>

<p>参考文档</p>
<ul>
<li><a href="http://blog.jobbole.com/99638/">Gradle入门：创建 Spring Boot Web 应用项目</a></li>
<li><a href="http://www.petrikainulainen.net/programming/gradle/getting-started-with-gradle-creating-a-spring-boot-web-application-project/">Getting Started with Gradle: Creating a Spring Boot Web Application Project</a></li>
<li><a href="https://github.com/pkainulainen/gradle-examples/tree/master/spring-boot-web-application">Github</a></li>
</ul>
<p>在一台远程服务器上运行Spring Web应用程序的传统做法是，将其打包为war文件并部署到servlet容器中。<br>
虽然在过去这个方法很好很强大，然而要同时管理多个servlet容器总是有些繁琐。<br>
Spring Boot针对该问题提供了一种解决方案，它允许我们将web应用程序打包为一个可执行的jar文件，这个文件可以使用嵌入式的servlet容器。</p>
<p>这篇博文将描述如何创建一个满足以下要求的Spring Boot web应用程序：</p>
<ul>
<li>Spring Boot应用程序必须使用Thymeleaf作为模版引擎。</li>
<li>Spring Boot应用程序必须提供一种对其进行监控的方式。</li>
<li>Gradle项目必须拥有独立的源文件和资源文件目录，以便进行单元和集成测试。</li>
</ul>
<p><strong>创建Java项目</strong><br>
由于我们需要创建的是一个Java项目，所以必须使用Java插件。通过以下步骤可以完成：</p>
<ul>
<li>应用Gradle的Java插件。</li>
<li>设置Java源码的版本为1.8。</li>
<li>配置Gradle生成Java1.8的class文件。</li>
</ul>
<p><strong>在Gradle构建中添加集成测试</strong><br>
我们可以使用Spring Boot Gradle插件在Gradle项目中添加Spring Boot的支持。通过以下步骤使用该插件：</p>
<ul>
<li>在构建脚本的classpath中添加Spring Boot Gradle插件（版本：1.2.5.RELEASE）。</li>
<li>应用Spring Boot Gradle插件。</li>
</ul>
<p>build.gradle文件的源代码如下：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>buildscript {
&#xA0;&#xA0;&#xA0;&#xA0;repositories {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;jcenter()
&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;&#xA0;&#xA0;dependencies { classpath( &apos;org.unbroken-dome.gradle-plugins:gradle-testsets-plugin:1.0.2&apos; ) }
}

apply plugin: &apos;java&apos;
apply plugin: &apos;org.unbroken-dome.test-sets&apos;

sourceCompatibility = 1.8
targetCompatibility = 1.8

testSets { integrationTest { dirName = &apos;integration-test&apos; }  }
&#xA0;
project.integrationTest { outputs.upToDateWhen { false } }
&#xA0;
check.dependsOn integrationTest
integrationTest.mustRunAfter test
&#xA0;
tasks.withType(Test) { reports.html.destination = file(&quot;${reporting.baseDir}/${name}&quot;) }
</code></pre><p><strong>在Gradle项目中添加Spring Boot的支持</strong></p>
<p>我们可以使用Spring Boot Gradle插件在Gradle项目中添加Spring Boot的支持。通过以下步骤使用该插件：</p>
<ul>
<li>在构建脚本的classpath中添加Spring Boot Gradle插件（版本：1.2.5.RELEASE）。<br>
<code>'org.springframework.boot:spring-boot-gradle-plugin:1.2.5.RELEASE'</code></li>
<li>应用Spring Boot Gradle插件。<br>
<code>apply plugin: 'spring-boot'</code></li>
</ul>
<p>我们无须使用Bintray的Jcenter Maven仓库，但是由于Gradle测试集插件依赖于该仓库，因此本文中的演示程序也将其加入。<br>
在应用Spring Boot Gradle插件后，我们可以：</p>
<ul>
<li>将应用程序打包为可执行的jar文件。</li>
<li>使用<code>bootrun</code>任务运行程序。</li>
<li>省略Spring Boot依赖的版本信息</li>
<li>将应用程序打包为war文件。</li>
<li></li>
</ul>
<p>当然，我们也可以对Spring Boot Gradle插件进行配置，并自定义执行和打包应用程序的任务。</p>
<p><strong>获取所需的依赖项</strong><br>
我们可以通过所谓的starter POM来获取Spring Boot应用的依赖。Spring Boot的参考指南将starter POM描述如下：<br>
starter POM是一族可以被包含到项目中的便捷依赖描述符。你可以一站式的获取所有需要的Spring和相关技术，无需苦苦寻找演示代码，也无需复制粘贴大量的依赖描述符。</p>
<p>换句话说，我们只需选择正确的starter POM，并将其加入到Gradle构建中即可。</p>
<ul>
<li>确保所有的依赖都从Maven2的中央仓库获取。</li>
<li>在<code>compile</code>配置里添加<code>spring-boot-starter-actuator</code>依赖，我们之所以需要这个依赖，是因为它提供了一种监控应用运行状态的方法。</li>
<li>在<code>compile</code>配置里添加<code>spring-boot-starter-thymeleaf</code>依赖，我们之所以需要该依赖，是因为我们需要使用<code>Thymeleaf</code>作为创建Web应用的模版引擎。</li>
<li>在<code>testCompile</code>配置里添加<code>spring-boot-starter-test</code>依赖，我们之所以需要该依赖，是因为我们需要在Web应用中编写单元测试和集成测试。</li>
</ul>
<p>build.gradle</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>buildscript {
&#xA0;&#xA0;&#xA0;&#xA0;repositories {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;jcenter()
&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;&#xA0;&#xA0;dependencies {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;classpath(
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&apos;org.springframework.boot:spring-boot-gradle-plugin:1.2.5.RELEASE&apos;,
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&apos;org.unbroken-dome.gradle-plugins:gradle-testsets-plugin:1.0.2&apos;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;)
&#xA0;&#xA0;&#xA0;&#xA0;}
}
&#xA0;
apply plugin: &apos;java&apos;
apply plugin: &apos;org.unbroken-dome.test-sets&apos;
apply plugin: &apos;spring-boot&apos;
&#xA0;
sourceCompatibility = 1.8
targetCompatibility = 1.8
&#xA0;
repositories {
&#xA0;&#xA0;&#xA0;&#xA0;mavenCentral()
}
&#xA0;&#xA0;
dependencies {
&#xA0;&#xA0;&#xA0;&#xA0;compile(
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&apos;org.springframework.boot:spring-boot-starter-actuator&apos;,
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;
&#xA0;&#xA0;&#xA0;&#xA0;)
&#xA0;&#xA0;&#xA0;&#xA0;testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)
}
&#xA0;
testSets {
&#xA0;&#xA0;&#xA0;&#xA0;integrationTest { dirName = &apos;integration-test&apos; }
}
&#xA0;
project.integrationTest {
&#xA0;&#xA0;&#xA0;&#xA0;outputs.upToDateWhen { false }
}
&#xA0;
check.dependsOn integrationTest
integrationTest.mustRunAfter test
&#xA0;
tasks.withType(Test) {
&#xA0;&#xA0;&#xA0;&#xA0;reports.html.destination = file(&quot;${reporting.baseDir}/${name}&quot;)
}
</code></pre><p><strong>运行Spring Boot 应用程序</strong></p>
<p>使用Spring Boot Gradle插件中的<code>bootRun</code>任务运行应用程序，而无需创建jar文件。</p>
<ul>
<li>我们应当在开发阶段使用这个方法，因为它可以使我们静态的classpath资源（即：在src/main/resources下的文件）都成为可重载的资源。</li>
<li>换句话说，如果我们使用这个方法，就可以在Spring Boot应用程序运行时对这些文件进行更改，而且可以在不重启应用的情况下观察到变化。</li>
</ul>
<p>可以将应用程序打包为一个可执行的jar文件，继而执行所创建的文件。</p>
<ul>
<li>如果想要在一台远程服务器上运行Spring Boot应用，应当采用这种方法。</li>
<li><code>gradle clean build</code> 命令会在<code>build/libs</code> 目录下创建<code>spring-boot-web-application.jar</code>文件。</li>
<li>在将其复制到远程服务器上后，可以通过以下命令运行应用程序。<br>
<code>java -jar spring-boot-web-application.jar</code></li>
</ul>
<hr>
<h2 class="mume-header" id="gradle%E6%9E%84%E5%BB%BAjava%E9%A1%B9%E7%9B%AE">Gradle构建java项目</h2>

<ul>
<li><a href="#javaplug">Java 插件</a></li>
<li><a href="#simpjava">简单java项目</a></li>
<li><a href="#japp">初始化java项目</a></li>
<li><a href="#javaapp">Java演示项目</a></li>
</ul>
<p><span id="javaplug"></span></p>
<h3 class="mume-header" id="java-%E6%8F%92%E4%BB%B6">Java 插件</h3>

<p><code>apply plugin: 'java'</code></p>
<p>如你所见, Gradle 是一种多用途的构建工具. 它可以在你的构建脚本里构建任何你想要实现的东西. 但前提是你必须先在构建脚本里加入代码, 不然它什么都不会执行.</p>
<p>大都数 Java 项目是非常相像的: 你需要编译你的 Java 源文件, 运行一些单元测试, 同时创建一个包含你类文件的 JAR. 如果你可以不需要为每一个项目重复编写这些, 我想你会非常乐意的.</p>
<p>幸运的是, 你现在不再需要做这些重复劳动了. Gradle 通过使用插件解决了这个问题. 插件是 Gradle 的扩展, 它会通过某种方式配置你的项目, 典型的有加入一些预配置任务. Gradle 自带了许多插件, 你也可以很简单地编写自己的插件并和其他开发者分享它. Java 插件就是一个这样的插件. 这个插件在你的项目里加入了许多任务， 这些任务会编译和单元测试你的源文件, 并且把它们都集成一个 JAR 文件里.</p>
<p>Java 插件是基于合约的. 这意味着插件已经给项目的许多方面定义了默认的参数, 比如 Java 源文件的位置. 如果你在项目里遵从这些合约, 你通常不需要在你的构建脚本里加入太多东西. 如果你不想要或者是你不能遵循合约, Gradle 也允许你自己定制你的项目. 事实上, 因为对 Java 项目的支持是通过插件实现的, 如果你不想要的话, 你一点也不需要使用这个插件来构建你的项目.</p>
<p><span id="simpjava"></span></p>
<h3 class="mume-header" id="%E6%9C%80%E7%AE%80%E5%8D%95java%E9%A1%B9%E7%9B%AE">最简单java项目</h3>

<p>目录结构</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>&#x251C;&#x2500;&#x2500; build.gradle
&#x2514;&#x2500;&#x2500; src
    &#x2514;&#x2500;&#x2500; main
        &#x2514;&#x2500;&#x2500; java
            &#x2514;&#x2500;&#x2500; SimpApp.java
</code></pre><p><strong>相关文件</strong></p>
<p>build.gradle</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;
</code></pre><p>Gradle 希望能在 <code>src/main/java</code> 找到你的源代码, 在 <code>src/test/java</code> 找到你的测试代码, 也就是说 Gradle 默认地在这些路径里查找资源. 另外, 任何在 <code>src/main/resources</code> 的文件都将被包含在 JAR 文件里, 同时任何在 <code>src/test/resources</code> 的文件会被加入到 <code>classpath</code> 中以运行测试代码. 所有的输出文件将会被创建在构建目录里, JAR 文件存放在 <code>build/libs</code> 文件夹里.</p>
<p>SimpApp.java</p>
<pre data-role="codeBlock" data-info="java" class="language-java"><span class="token comment">/*
 * This Java source file was generated by the Gradle 'init' task.
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpApp</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> String <span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Hello world."</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre><p><strong>构建运行</strong></p>
<ul>
<li>构建： <code>gradle build</code></li>
<li>运行：<br>
<code>java -cp build/classes/main SimpApp</code><br>
<code>java -cp build/libs/simpjava.jar SimpApp</code></li>
</ul>
<p><strong>修改 build.gradle</strong></p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;

//jar&#x6587;&#x4EF6;&#x589E;&#x52A0;manifest&#x4FE1;&#x606F;
jar {
    manifest {
        attributes &apos;Main-Class&apos;: &apos;SimpApp&apos;
    }
}

//&#x4F7F;&#x7528;application&#x63D2;&#x4EF6;&#xFF0C;&#x652F;&#x6301; &quot;gradle run&quot;
apply plugin: &apos;application&apos;
mainClassName = &apos;SimpApp&apos;
</code></pre><p><strong>构建运行</strong></p>
<ul>
<li>构建： <code>gradle build</code></li>
<li>运行： <code>java -jar build/libs/simpjava.jar</code></li>
<li>构建运行： <code>gradle run</code></li>
</ul>
<p><span id="japp"></span></p>
<h3 class="mume-header" id="%E5%88%9D%E5%A7%8B%E5%8C%96java%E9%A1%B9%E7%9B%AE-japp">初始化java项目 (japp)</h3>

<p><strong>初始化 java-application 项目</strong><br>
<code>gradle init --type=java-application</code></p>
<p>目录结构</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>&#x251C;&#x2500;&#x2500; build.gradle
&#x251C;&#x2500;&#x2500; gradle
&#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; wrapper
&#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; gradle-wrapper.jar
&#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; gradle-wrapper.properties
&#x251C;&#x2500;&#x2500; gradlew
&#x251C;&#x2500;&#x2500; gradlew.bat
&#x251C;&#x2500;&#x2500; settings.gradle
&#x2514;&#x2500;&#x2500; src
    &#x251C;&#x2500;&#x2500; main
    &#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; java
    &#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; App.java
    &#x2514;&#x2500;&#x2500; test
        &#x2514;&#x2500;&#x2500; java
            &#x2514;&#x2500;&#x2500; AppTest.java
</code></pre><p><strong>相关文件</strong></p>
<p>build.gradle</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>/*
 * This build file was generated by the Gradle &apos;init&apos; task.
 *
 * This generated file contains a sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at https://docs.gradle.org/3.4/userguide/tutorial_java_projects.html
 */

// Apply the java plugin to add support for Java
apply plugin: &apos;java&apos;

// Apply the application plugin to add support for building an application
apply plugin: &apos;application&apos;

// In this section you declare where to find the dependencies of your project
repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

dependencies {
    // This dependency is found on compile classpath of this component and consumers.
    compile &apos;com.google.guava:guava:20.0&apos;

    // Use JUnit test framework
    testCompile &apos;junit:junit:4.12&apos;
}

// Define the main class for the application
mainClassName = &apos;App&apos;
</code></pre><p>settings.gradle</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>/*
 * This settings file was generated by the Gradle &apos;init&apos; task.
 *
 * The settings file is used to specify which projects to include in your build.
 * In a single project build this file can be empty or even removed.
 *
 * Detailed information about configuring a multi-project build in Gradle can be found
 * in the user guide at https://docs.gradle.org/3.4/userguide/multi_project_builds.html
 */

/*
// To declare projects as part of a multi-project build use the &apos;include&apos; method
include &apos;shared&apos;
include &apos;api&apos;
include &apos;services:webservice&apos;
*/

rootProject.name = &apos;japp&apos;
</code></pre><p><strong>构建运行</strong></p>
<ul>
<li>构建： <code>gradle build</code></li>
<li>运行：<br>
<code>java -cp build/classes/main App</code><br>
<code>java -cp build/libs/japp.jar App</code></li>
<li>构建运行： <code>gradle run</code></li>
</ul>
<p><span id="javaapp"></span></p>
<h3 class="mume-header" id="java%E6%BC%94%E7%A4%BA%E9%A1%B9%E7%9B%AE-javaapp">Java演示项目 (javaapp)</h3>

<p><strong>项目说明</strong></p>
<ul>
<li>演示程序的构建脚本必须使用Maven central仓库。</li>
<li>演示程序必须使用Log4j写入日志。</li>
<li>演示程序必须包含包含单元测试，保证正确的信息返回，单元测试必须使用JUnit编写。</li>
<li>演示程序必须创建一个可执行的Jar文件。</li>
</ul>
<p><strong>项目目录结构</strong></p>
<pre data-role="codeBlock" data-info="" class="language-"><code>.
&#x251C;&#x2500;&#x2500; build.gradle
&#x251C;&#x2500;&#x2500; gradle
&#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; wrapper
&#x2502;&#xA0;&#xA0;     &#x251C;&#x2500;&#x2500; gradle-wrapper.jar
&#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; gradle-wrapper.properties
&#x251C;&#x2500;&#x2500; gradlew
&#x251C;&#x2500;&#x2500; gradlew.bat
&#x251C;&#x2500;&#x2500; settings.gradle
&#x2514;&#x2500;&#x2500; src
    &#x251C;&#x2500;&#x2500; main
    &#x2502;&#xA0;&#xA0; &#x251C;&#x2500;&#x2500; java
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; com
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; dsl
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0;         &#x2514;&#x2500;&#x2500; gradle
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0;             &#x251C;&#x2500;&#x2500; HelloWorld.java
    &#x2502;&#xA0;&#xA0; &#x2502;&#xA0;&#xA0;             &#x2514;&#x2500;&#x2500; MessageService.java
    &#x2502;&#xA0;&#xA0; &#x2514;&#x2500;&#x2500; resources
    &#x2502;&#xA0;&#xA0;     &#x2514;&#x2500;&#x2500; log4j.properties
    &#x2514;&#x2500;&#x2500; test
        &#x2514;&#x2500;&#x2500; java
            &#x2514;&#x2500;&#x2500; com
                &#x2514;&#x2500;&#x2500; dsl
                    &#x2514;&#x2500;&#x2500; gradle
                        &#x2514;&#x2500;&#x2500; MessageServiceTest.java
</code></pre><p>说明</p>
<ul>
<li><code>MessageService.java</code> 创建一个<code>MessageService</code>类，当其中的<code>getMessage()</code>方法被调用时，返回字符串<code>“Hello World!”</code>。</li>
<li><code>MessageServiceTest.java</code> 创建一个<code>MessageServiceTest</code>类，确保M<code>essageService</code>类中的<code>getMessage()</code>方法返回字符串<code>“Hello World!”</code>。</li>
<li><code>HelloWorld.java</code> 创建程序的主类，从<code>MessageService</code>对象获取信息，并使用<code>Log4j</code>写入日志。</li>
<li><code>log4j.properties</code> 配置<code>Log4j</code>。</li>
</ul>
<p><strong><code>build.gradle</code> 文件</strong></p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;
apply plugin: &apos;application&apos;

// &#x914D;&#x7F6E;&#x4ED3;&#x5E93;
repositories {
  mavenCentral()
}

// &#x4F9D;&#x8D56;&#x58F0;&#x660E;
dependencies {
  compile &apos;log4j:log4j:1.2.17&apos;
  testCompile &apos;junit:junit:4.12&apos;
}

// &#x6253;&#x5305;jar
jar {
  from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
  manifest {
    attributes &apos;Main-Class&apos;: &apos;com.dsl.gradle.HelloWorld&apos;
  }
}

mainClassName = &apos;com.dsl.gradle.HelloWorld&apos;
</code></pre><blockquote>
<p>说明：<br>
jar包中包含依赖的库<br>
<code>from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }</code></p>
</blockquote>
<p><strong>执行测试</strong></p>
<p><code>gradle test</code></p>
<ul>
<li><code>build/test-results</code> 目录包含每次测试执行的原始数据。</li>
<li><code>build/reports/tests</code> 目录包含一个HTML报告，描述了测试的结果。</li>
</ul>
<p><strong>打包和运行程序</strong></p>
<p><code>gradle assemble</code>或<code>gradle build</code></p>
<ul>
<li>生成: <code>build/libs/javaapp.jar</code></li>
<li>运行:<br>
<code>java -jar build/libs/javaapp.jar</code><br>
<code>java -cp build/classes/main com.dsl.gradle.HelloWorld</code></li>
</ul>
<hr>
<p><span id="javaguide"></span></p>
<h2 class="mume-header" id="java-%E6%9E%84%E5%BB%BA%E5%85%A5%E9%97%A8">Java 构建入门</h2>

<p><a href="https://docs.gradle.org/3.4.1/userguide/userguide.html">Gradle docs 46. Java Quickstart</a></p>
<h3 class="mume-header" id="java-%E6%8F%92%E4%BB%B6-1">Java 插件</h3>

<p>如你所见, Gradle 是一种多用途的构建工具. 它可以在你的构建脚本里构建任何你想要实现的东西. 但前提是你必须先在构建脚本里加入代码, 不然它什么都不会执行.</p>
<p>大都数 Java 项目是非常相像的: 你需要编译你的 Java 源文件, 运行一些单元测试, 同时创建一个包含你类文件的 JAR. 如果你可以不需要为每一个项目重复编写这些, 我想你会非常乐意的.</p>
<p>幸运的是, 你现在不再需要做这些重复劳动了. Gradle 通过使用插件解决了这个问题. 插件是 Gradle 的扩展, 它会通过某种方式配置你的项目, 典型的有加入一些预配置任务. Gradle 自带了许多插件, 你也可以很简单地编写自己的插件并和其他开发者分享它. Java 插件就是一个这样的插件. 这个插件在你的项目里加入了许多任务， 这些任务会编译和单元测试你的源文件, 并且把它们都集成一个 JAR 文件里.</p>
<p>Java 插件是基于合约的. 这意味着插件已经给项目的许多方面定义了默认的参数, 比如 Java 源文件的位置. 如果你在项目里遵从这些合约, 你通常不需要在你的构建脚本里加入太多东西. 如果你不想要或者是你不能遵循合约, Gradle 也允许你自己定制你的项目. 事实上, 因为对 Java 项目的支持是通过插件实现的, 如果你不想要的话, 你一点也不需要使用这个插件来构建你的项目.</p>
<h3 class="mume-header" id="%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84-java-%E9%A1%B9%E7%9B%AE">一个基础的 Java 项目</h3>

<p><code>build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;
</code></pre><p>Gradle 希望能在 <code>src/main/java</code> 找到你的源代码, 在 <code>src/test/java</code> 找到你的测试代码, 也就是说 Gradle 默认地在这些路径里查找资源. 另外, 任何在 <code>src/main/resources</code> 的文件都将被包含在 JAR 文件里, 同时任何在 <code>src/test/resources</code> 的文件会被加入到 <code>classpath</code> 中以运行测试代码. 所有的输出文件将会被创建在构建目录里, JAR 文件存放在 <code>build/libs</code> 文件夹里.</p>
<p><strong>创建可执行应用</strong><br>
<code>build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;application&apos;
mainClassName = &apos;com.dm.todo.ToDoApp&apos;
</code></pre><p><strong>外部依赖</strong></p>
<p>一个 Java 项目有许多外部的依赖, 既是指外部的 JAR 文件. 在 Gradle 中, JAR 文件位于一个仓库中， 这里的仓库类似于 MAVEN 的仓库. 仓库可以被用来提取依赖, 或者放入一个依赖, 或者两者皆可.<br>
<code>build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>// &#x52A0;&#x5165; Maven &#x4ED3;&#x5E93;
repositories {
    mavenCentral()
}

// &#x52A0;&#x5165;&#x4E00;&#x4E9B;&#x4F9D;&#x8D56;
dependencies {
    compile group: &apos;commons-collections&apos;, name: &apos;commons-collections&apos;, version: &apos;3.2.2&apos;
    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.+&apos;
}
</code></pre><p><strong>定制项目</strong></p>
<p>Java 插件给项目加入了一些属性 (propertiy). 这些属性已经被赋予了默认的值, 已经足够来开始构建项目了. 如果你认为不合适, 改变它们的值也是很简单的.<br>
<code>build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>//&#x5B9A;&#x5236; MANIFEST.MF &#x6587;&#x4EF6;
sourceCompatibility = 1.7
version = &apos;1.0&apos;
jar {
    manifest {
        attributes &apos;Implementation-Title&apos;: &apos;Gradle Quickstart&apos;, &apos;Implementation-Version&apos;: version
    }
}

//&#x6D4B;&#x8BD5;&#x9636;&#x6BB5;&#x52A0;&#x5165;&#x4E00;&#x4E2A;&#x7CFB;&#x7EDF;&#x5C5E;&#x6027;
test {
    systemProperties &apos;property&apos;: &apos;value&apos;
}
</code></pre><p><strong>发布 JAR 文件</strong></p>
<p>通常 JAR 文件需要在某个地方发布. 为了完成这一步, 你需要告诉 Gradle 哪里发布 JAR 文件. 在 Gradle 里, 生成的文件比如 JAR 文件将被发布到仓库里. 在我们的例子里, 我们将发布到一个本地的目录. 你也可以发布到一个或多个远程的地点.<br>
<code>build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>uploadArchives {
    repositories {
       flatDir {
           dirs &apos;repos&apos;
       }
    }
}
</code></pre><p><strong>创建 Eclipse 项目</strong></p>
<p>为了把你的项目导入到 Eclipse, 你需要加入一个插件。 运行 gradle eclipse 命令来生成 Eclipse 的项目文件。<br>
<code>build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;eclipse&apos;
</code></pre><p><strong>完整build.gradle文件</strong><br>
build.gradle</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply plugin: &apos;java&apos;
apply plugin: &apos;eclipse&apos;

sourceCompatibility = 1.7
version = &apos;1.0&apos;
jar {
    manifest {
        attributes &apos;Implementation-Title&apos;: &apos;Gradle Quickstart&apos;, &apos;Implementation-Version&apos;: version
    }
}

repositories {
    mavenCentral()
}

dependencies {
    compile group: &apos;commons-collections&apos;, name: &apos;commons-collections&apos;, version: &apos;3.2.2&apos;
    testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.+&apos;
}

test {
    systemProperties &apos;property&apos;: &apos;value&apos;
}

uploadArchives {
    repositories {
       flatDir {
           dirs &apos;repos&apos;
       }
    }
}


test {
    systemProperty &quot;file.encoding&quot;, &quot;utf-8&quot;
    filter {
        includeTestsMatching &quot;sia.knights.*&quot;
    }
}

// Pass-through &apos;System.out &amp; err&apos; into output window during execution of JUnit test
test.testLogging {
    showStandardStreams = true
}
</code></pre><h3 class="mume-header" id="%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%9A%84-java-%E6%9E%84%E5%BB%BA">多项目的 Java 构建</h3>

<p>典型的多项目构建的项目布局</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>multiproject/
  api/
  services/webservice/
  shared/
  services/shared/
</code></pre><p><strong>定义一个多项目构建</strong></p>
<p>为了定义一个多项目构建, 你需要创建一个设置文件 <code>settings.gradle</code>. 设置文件放在源代码的根目录, 它指定要包含哪个项目.<br>
<code>settings.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>include &quot;shared&quot;, &quot;api&quot;, &quot;services:webservice&quot;, &quot;services:shared&quot;
</code></pre><p><strong>通用配置</strong></p>
<p>对于绝大多数多项目构建, 有一些配置对所有项目都是常见的或者说是通用的. 在我们的例子里, 我们将在根项目里定义一个这样的通用配置, 使用一种叫做配置注入的技术 (configuration injection). 这里, 根项目就像一个容器, <code>subprojects</code> 方法遍历这个容器的所有元素并且注入指定的配置 . 通过这种方法, 我们可以很容易的定义所有档案和通用依赖的内容清单:</p>
<p><code>build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>subprojects {
    apply plugin: &apos;java&apos;
    apply plugin: &apos;eclipse-wtp&apos;

    repositories {
       mavenCentral()
    }

    dependencies {
        testCompile &apos;junit:junit:4.12&apos;
    }

    version = &apos;1.0&apos;
    jar {
        manifest.attributes provider: &apos;gradle&apos;
    }
}
</code></pre><p><strong>项目之间的依赖</strong></p>
<p>你可以在同一个构建里加入项目之间的依赖, 举个例子, 一个项目的 JAR 文件被用来编译另外一个项目. 在 <code>api</code> 构建文件里我们将加入一个由 <code>shared</code> 项目产生的 JAR 文件的依赖. 由于这个依赖, Gradle 将确保 <code>shared</code> 项目总是在 <code>api</code> 之前被构建.</p>
<p><code>api/build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>dependencies {
    compile project(&apos;:shared&apos;)
}
</code></pre><p><strong>创建一个发行版本</strong></p>
<p>我们同时也加入了一个发行版本, 将会送到客户端:</p>
<p><code>api/build.gradle</code> 文件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>task dist(type: Zip) {
    dependsOn spiJar
    from &apos;src/dist&apos;
    into(&apos;libs&apos;) {
        from spiJar.archivePath
        from configurations.runtime
    }
}

artifacts {
   archives dist
}
</code></pre><hr>
<h2 class="mume-header" id="java-gradle%E4%B9%8Bgretty%E6%8F%92%E4%BB%B6">Java Gradle之gretty插件</h2>

<p>参考文档</p>
<ul>
<li><a href="http://akhikhl.github.io/gretty-doc/">Gretty documentation</a></li>
<li><a href="https://github.com/akhikhl/gretty">GitHub akhikhl/gretty</a></li>
<li><a href="http://www.cnblogs.com/gzdaijie/p/5267166.html">Java Gradle入门指南之gretty插件（安装、命令与核心特性） </a></li>
</ul>
<p>gretty 插件支持 Jetty 和 Tomcat。<br>
gretty支持热部署、HTTPS、转发、调试、自动化运行环境等诸多特性，让开发和部署变得更加简单。</p>
<p><strong>安装gretty</strong></p>
<p><code>build.gradle</code> 加入 gretty 插件</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>apply from: &apos;https://raw.github.com/akhikhl/gretty/master/pluginScripts/gretty.plugin&apos;
</code></pre><p>或者</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>buildscript {
  repositories { jcenter() }
  dependencies { classpath &apos;org.akhikhl.gretty:gretty:+&apos; }
}

apply plugin: &apos;org.akhikhl.gretty&apos;
</code></pre><p><strong>常用命令</strong></p>
<ul>
<li>gradle appRun
<ul>
<li>编译当前项目</li>
<li>不依赖于war任务</li>
<li>另有appRunWar、appRunDebug、appRunWarDebug</li>
</ul>
</li>
<li>gradle appStart
<ul>
<li>编译当前项目</li>
<li>使用新java线程开启服务，监听端口，等待HTTP请求</li>
<li>不依赖于war任务</li>
<li>不主动关闭服务，即一直在运行，需用gradle appStop关闭</li>
<li>另有appStartWar、appStartDebug、appStartWarDebug</li>
</ul>
</li>
<li>gradle jetty* / gradle tomcat*<br>
包含Start、Run、Stop等</li>
</ul>
<p><strong>核心特性</strong></p>
<p>选择servlet 容器</p>
<ul>
<li><code>contextPath</code> 设置根路径，默认为项目名称</li>
<li><code>httpPort</code> 端口默认<code>8080</code>, <code>port</code>已作废</li>
<li><code>serlvetContainer</code> 支持 jetty7/8/9，tomcat7/8</li>
<li><code>build.gradle</code> 添加</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-"><code>gretty {
  httpPort = 8080
  serlvetContainer = &apos;jetty9&apos;
  contextPath = &apos;/&apos;
}
</code></pre><p>热部署</p>
<ul>
<li>scanInterval：监视周期，单位为秒，设置为0等于完全关闭热部署</li>
<li>scanDir：需要监视的文件夹</li>
<li>recompileOnSourceChange：监视源码变动，自动编译</li>
<li>reloadOnClassChange：编译的类发生改变，自动加载</li>
<li>reloadOnConfigChange：WEB-INF或META-INF发生改变</li>
<li>reloadOnLibChange：依赖发生改变</li>
</ul>
<p>快速加载</p>
<ul>
<li>fastReload属性，默认为true，监听webapp/中的内容，文件发生改变，无需重启。</li>
</ul>
<p>添加新的资源目录</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>gretty{
&#xA0;&#xA0;&#xA0;&#xA0;// ...
&#xA0;&#xA0;&#xA0;&#xA0;extraResourceBase &apos;dir1&apos;,
&#xA0;&#xA0;&#xA0;&#xA0;extraResourceBases &apos;dir2&apos;,&apos;dir3&apos;
&#xA0;&#xA0;&#xA0;&#xA0;// ...
}
</code></pre><p>HTTPS 支持</p>
<ul>
<li>生成自签名证书，仅在开发时使用</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-"><code>gretty {
  httpsEnabled = true
  // httpEnabled = false &#x7981;&#x7528;http
  // httpsPort = 443 httpsPort&#x9ED8;&#x8BA4;&#x4E3A; 8443
}
</code></pre><ul>
<li>支持手动配置</li>
</ul>
<p>转发</p>
<ul>
<li>在<code>WEB-INF/web.xml</code>中加入 <code>RedirectFilter</code>设置</li>
<li>创建WEB-INF/filter.groovy，设置转发规则</li>
</ul>
<p>调试（Debug）</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>// &#x4E3A;&#x6240;&#x6709;&#x7684;debug&#x547D;&#x4EE4;&#x914D;&#x7F6E;&#x53C2;&#x6570;
gretty {
&#xA0;&#xA0;debugPort = 5005&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; // &#x9ED8;&#x8BA4;
&#xA0;&#xA0;debugSuspend = true&#xA0;&#xA0; // &#x9ED8;&#x8BA4;
}

// &#x4EC5;&#x9488;&#x5BF9;appRunDebug
gretty {
&#xA0;&#xA0;afterEvaluate {
&#xA0;&#xA0;&#xA0;&#xA0;appRunDebug {
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;debugPort = 5005
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;debugSuspend = true
&#xA0;&#xA0;&#xA0;&#xA0;}
&#xA0;&#xA0;}
}
</code></pre><p><strong>产品生成</strong></p>
<p><code>gradle buildProduct</code></p>
<ul>
<li>生成安装文件</li>
<li>生成目录位于 <code>build/output/${project.name}</code></li>
</ul>
<p><code>gradle archiveProduct</code></p>
<ul>
<li>打包生成的安装文件</li>
<li>生成目录位于 <code>build/output/${project.name}</code></li>
</ul>

      </div>
      <div class="md-sidebar-toc"><ul>
<li><a href="#gradle-user-guide">Gradle User Guide</a></li>
<li><a href="#gradle-cargo-plugin%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8">Gradle Cargo plugin部署项目到远程服务器</a></li>
<li><a href="#gradle-ssh-plugin%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8">Gradle SSH Plugin部署项目到远程服务器</a></li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E7%AE%80%E4%BB%8B">Gradle入门系列：简介</a>
<ul>
<li><a href="#gradle%E6%9E%84%E5%BB%BA%E7%AE%80%E4%BB%8B">Gradle构建简介</a></li>
<li><a href="#gradle%E6%8F%92%E4%BB%B6%E7%AE%80%E4%BB%8B">Gradle插件简介</a></li>
</ul>
</li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E9%A1%B9%E7%9B%AE">Gradle入门系列：第一个Java项目</a></li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">Gradle入门系列：依赖管理</a>
<ul>
<li><a href="#java%E6%BC%94%E7%A4%BA%E9%A1%B9%E7%9B%AE">Java演示项目</a></li>
</ul>
</li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC">Gradle入门系列：创建二进制发布版本</a></li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BA%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">Gradle入门系列：创建多项目构建</a>
<ul>
<li><a href="#gradle-build-%E7%9A%84%E9%9C%80%E6%B1%82">Gradle Build 的需求</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%A4%9A%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA">创建一个多项目构建</a></li>
</ul>
</li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BAweb%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE">Gradle入门系列：创建Web应用项目</a></li>
<li><a href="#gradle%E5%85%A5%E9%97%A8%E5%88%9B%E5%BB%BA-spring-boot-web-%E5%BA%94%E7%94%A8%E9%A1%B9%E7%9B%AE">Gradle入门：创建 Spring Boot Web 应用项目</a></li>
<li><a href="#gradle%E6%9E%84%E5%BB%BAjava%E9%A1%B9%E7%9B%AE">Gradle构建java项目</a>
<ul>
<li><a href="#java-%E6%8F%92%E4%BB%B6">Java 插件</a></li>
<li><a href="#%E6%9C%80%E7%AE%80%E5%8D%95java%E9%A1%B9%E7%9B%AE">最简单java项目</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96java%E9%A1%B9%E7%9B%AE-japp">初始化java项目 (japp)</a></li>
<li><a href="#java%E6%BC%94%E7%A4%BA%E9%A1%B9%E7%9B%AE-javaapp">Java演示项目 (javaapp)</a></li>
</ul>
</li>
<li><a href="#java-%E6%9E%84%E5%BB%BA%E5%85%A5%E9%97%A8">Java 构建入门</a>
<ul>
<li><a href="#java-%E6%8F%92%E4%BB%B6-1">Java 插件</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84-java-%E9%A1%B9%E7%9B%AE">一个基础的 Java 项目</a></li>
<li><a href="#%E5%A4%9A%E9%A1%B9%E7%9B%AE%E7%9A%84-java-%E6%9E%84%E5%BB%BA">多项目的 Java 构建</a></li>
</ul>
</li>
<li><a href="#java-gradle%E4%B9%8Bgretty%E6%8F%92%E4%BB%B6">Java Gradle之gretty插件</a></li>
</ul>
</div>
      <a id="sidebar-toc-btn">≡</a>
    </body>
    
    
    
    
    
    
    
<script>
document.body.setAttribute('html-show-sidebar-toc', true)
var sidebarTOCBtn = document.getElementById('sidebar-toc-btn')
sidebarTOCBtn.addEventListener('click', function(event) {
  event.stopPropagation()
  if (document.body.hasAttribute('html-show-sidebar-toc')) {
    document.body.removeAttribute('html-show-sidebar-toc')
  } else {
    document.body.setAttribute('html-show-sidebar-toc', true)
  }
})
</script>
      
  </html>